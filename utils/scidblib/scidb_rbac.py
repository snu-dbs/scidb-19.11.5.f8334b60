#!/usr/bin/env python

# BEGIN_COPYRIGHT
#
# Copyright (C) 2008-2019 SciDB, Inc.
# All Rights Reserved.
#
# SciDB is free software: you can redistribute it and/or modify
# it under the terms of the AFFERO GNU General Public License as published by
# the Free Software Foundation.
#
# SciDB is distributed "AS-IS" AND WITHOUT ANY WARRANTY OF ANY KIND,
# INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,
# NON-INFRINGEMENT, OR FITNESS FOR A PARTICULAR PURPOSE. See
# the AFFERO GNU General Public License for the complete license terms.
#
# You should have received a copy of the AFFERO GNU General Public License
# along with SciDB.  If not, see <http://www.gnu.org/licenses/agpl-3.0.html>
#
# END_COPYRIGHT

"""
Functions for reading, formatting, and writing SciDB role-based access
control (RBAC) metadata.

Used by scidb_backup.py and by the stand-alone rbactool.py utility.
"""

import json
import pprint as pp
import re
import sys

from scidblib.iquery_client import IQuery
from scidblib.util import Bunch

DBA_USER = 'scidbadmin'
PUBLIC_NS = 'public'

debug_logging = False
_log_prefix = 'scidb_rbac:'


def prt(*args, **kwargs):
    """Write args to stdout."""
    print ' '.join(str(x) for x in args)


def warn(*args, **kwargs):
    """Write '{0} args' to stderr.""".format(_log_prefix)
    print >>sys.stderr, _log_prefix, ' '.join(str(x) for x in args)


def dbg(*args, **kwargs):
    """Call 'warn(*args)' iff debug_logging is enabled."""
    if debug_logging:
        warn(*args)


def read_pg(psql, canonical=True):
    """Read raw SciDB metadata tables from Postgres into a bunch.

    psql - a psql_client.Psql() object
    canonical - eliminate autoid numbers in results
    """
    assert psql, "No Postgres client?!"

    # Read raw RBAC-related tables.
    b = Bunch()
    b.metadata_version = psql(
        "SELECT metadata_version FROM cluster")[0].metadata_version
    b.users = [x._asdict() for x in psql("SELECT * FROM users")]
    b.spaces = [x._asdict() for x in psql("SELECT * FROM namespaces")]
    b.roles = [x._asdict() for x in psql("SELECT * FROM roles")]
    b.role_members = [x._asdict() for x in
                      psql("SELECT * FROM role_members")]
    b.perms = [x._asdict() for x in
               psql("SELECT * FROM role_namespace_permissions")]

    # Add auxilliary id-->entity maps to the bunch.
    b.user_ids = dict([(x['id'], x) for x in b.users])
    b.namespace_ids = dict([(x['id'], x) for x in b.spaces])
    b.role_ids = dict([(x['id'], x) for x in b.roles])

    return canonicalize(b) if canonical else b


def is_canonical(bunch):
    """Return true iff bunch is canonical."""
    # So we don't have to remember hasattr calls everywhere.
    if hasattr(bunch, 'is_canonical'):
        return bunch.is_canonical
    else:
        return False


def canonicalize(bunch):
    """Derive a canonical bunch from a raw bunch.

    The raw input bunch is left intact.  If the input bunch is already
    canonical, it is returned as-is.  Canonical bunches:

    - Contain no id numbers based on Postgres sequences (names are
      used instead).

    - Don't have auxilliary id-->entity mapping attributes.

    - Eliminate entries for the per-user roles that are automatically
      generated by create_user().  This ensures no extraneous
      create_role() queries will be generated from the canonical
      bunch.
    """

    if is_canonical(bunch):
        # Don't recanonicalize!
        return bunch

    def canon_dict(din):
        """Return canonical dict based on din, skipping 'id' field(s)."""
        # This works because the RBAC tables have a naming convention.
        dout = dict()
        for key in sorted(din.keys()):
            if key == 'id':
                continue
            if key.endswith('_id'):
                k = key[:-3]
                idmap = getattr(bunch, "%s_ids" % k, None)
                assert idmap, "Key '%s' violates naming convention!" % key
                dout[k] = idmap[din[key]]['name']
            else:
                dout[key] = din[key]
        return dout

    b = Bunch()                 # new result bunch
    b.is_canonical = True
    b.metadata_version = bunch.metadata_version

    users = [canon_dict(x) for x in bunch.users]
    users.sort()
    b.users = users
    usernames = set(x['name'] for x in users)
    roles = [x['name'] for x in bunch.roles]
    # Eliminate automatic per-user roles.
    roles = [x for x in roles if x not in usernames]
    roles.sort()
    b.roles = roles
    spaces = [x['name'] for x in bunch.spaces]
    spaces.sort()
    b.spaces = spaces
    role_members = [canon_dict(x) for x in bunch.role_members]
    # Eliminate automatic per-user roles.
    role_members = [x for x in role_members if x['role'] != x['user']]
    role_members.sort()
    b.role_members = role_members
    perms = [canon_dict(x) for x in bunch.perms]
    perms.sort()
    b.perms = perms
    return b


def to_json(bunch):
    """Format bunch of PG tables as JSON."""
    # Keep these kwargs, otherwise tests will hate you.
    return json.dumps(bunch.__dict__, sort_keys=True, indent=2,
                      separators=(',', ': '))


def from_json(s):
    """Build bunch of PG tables from JSON."""
    b = Bunch()
    doc = json.loads(s)
    b.__dict__.update(doc)
    # Input may have been hand-edited, supply some missing attributes.
    for attr in "perms role_members roles users spaces".split():
        if attr not in b.__dict__:
            setattr(b, attr, [])
    return b


def to_afl(bunch):
    """Convert RBAC bunch to list of AFL commands needed to recreate it.

    The bunch must be in canonical form.
    """
    assert is_canonical(bunch), "Cannot translate non-canonical bunch to AFL"

    # Start by creating entities: users, namespaces, roles.
    cmds = []
    usernames = set()
    for user in bunch.users:
        usernames.add(user['name'])
        if user['name'] == DBA_USER:
            dbg("No create_user() command needed for", DBA_USER)
            continue
        cmds.append("create_user('{name}', '{password}',"
                    " _method:'{method}', _salt:'{salt}')".format(**user))
    for ns in bunch.spaces:
        if ns == PUBLIC_NS:
            dbg("No create_namespace() command needed for public namespace")
            continue
        cmds.append("create_namespace(%s)" % ns)
    for role in bunch.roles:
        assert role not in usernames, "Per-user role in canonical bunch?!"
        cmds.append("create_role('%s')" % role)

    # Add users to roles per the role_members table.
    for membership in bunch.role_members:
        role = membership['role']
        user = membership['user']
        assert role != user, "Per-user role membership in canonical bunch?!"
        cmds.append("add_user_to_role('{0}', '{1}')".format(user, role))

    # Add role permissions for namespaces.
    for perm in bunch.perms:
        cmds.append(
            "set_role_permissions('{role}', {namespace}, '{permissions}')"
            .format(**perm))

    return cmds


def _split_one_list(got, want, name_of=lambda x: x):
    """Given 'got', decide which 'want' items are needed and which not.

    got - list of entities (user, role, etc.) in the catalog
    want - corresponding list of entities from the input file
    name_of - function for extracting entity name

    Returns pair of lists (keep, toss) where 'keep' is the set
    complement (want - got) and 'toss' is the set intersection of want
    and got.
    """
    keep = []
    toss = []
    got_names = set([name_of(x) for x in got])
    for item in want:
        name = name_of(item)
        if name in got_names:
            toss.append(item)
        else:
            keep.append(item)
    return keep, toss


def merge(got, want):
    """Compare wanted RBAC with existing RBAC, and derive needed updates.

    The Postgres database has 'got' some RBAC records.  We have some
    RBAC metadata we 'want' to restore.  But not all of them should be
    restored.  Here we decide which updates to allow.

    - Disallow redundant updates, for example if user 'alice' is
      already present in PG we don't want to call
      "create_user('alice',...)" again.

    - Disallow any update that would cause a privilege escalation for
      a pre-existing user or role.
    """
    assert is_canonical(got) and is_canonical(want), (
        "Cannot merge non-canonical bunch!")

    # Everybody complains about a version mismatch, but nobody does
    # anything about it.  There's no backward compatibility issues
    # *yet*, but one day there might be.
    if got.metadata_version != want.metadata_version:
        warn("SciDB metadata version mismatch, db:{0} != input_file:{1}"
             .format(got.metadata_version, want.metadata_version))

    result = Bunch()
    result.is_canonical = True
    result.metadata_version = got.metadata_version

    # Collect conflicting pre-existing items here as we find them.
    # Needed to check for possible privilege escalations.
    exists = Bunch()

    # Divide users into new-from-backup and pre-existing.
    result.users, exists.users = _split_one_list(got.users, want.users,
                                                 name_of=lambda x: x['name'])
    toss = [x['name'] for x in exists.users if x['name'] != DBA_USER]
    if toss:
        warn("Skipping users who already exist:\n", pp.pformat(toss))

    # Divide roles into new-from-backup and pre-existing.
    result.roles, exists.roles = _split_one_list(got.roles, want.roles)
    if exists.roles:
        warn("Skipping roles that already exist:\n", pp.pformat(exists.roles))

    # Divide namespaces into new-from-backup and pre-existing.
    result.spaces, exists.spaces = _split_one_list(got.spaces, want.spaces)
    toss = [x for x in exists.spaces if x != PUBLIC_NS]
    if toss:
        warn("Skipping namespaces that already exist:\n", pp.pformat(toss))

    # Don't restore any role memberships for users who already exist.
    exists.usernames = [x['name'] for x in exists.users]
    want_mships = [x for x in want.role_members
                   if x['user'] not in exists.usernames]
    toss = [x for x in want.role_members if x not in want_mships]
    if toss:
        warn("Skipping role memberships for pre-existing users:\n",
             pp.pformat(toss))

    # Don't restore any role memberships that already exist, period.
    result.role_members, exists.role_members = _split_one_list(
        got.role_members, want_mships, name_of=pp.pformat)
    if exists.role_members:
        warn("Skipping role memberships that already exist:\n",
             pp.pformat(exists.role_members))

    # Check want.perms against the set of (role, ns) pairs for all
    # pre-exisiting (role, ns, perms) triples.  If the existing
    # catalog has a permission, it shouldn't be overwritten from
    # backup.  Otherwise, either:
    #  (a) role existed but not namespace: re-grant role's access, or
    #  (b) namespace existed but not role: let restored role have access, or
    #  (c) neither existed, it's a full restore from backup.
    #
    result.perms, exists.perms = _split_one_list(
        got.perms, want.perms, name_of=lambda x: (x['role'], x['namespace']))
    if exists.perms:
        warn("Skipping permissions that would overwrite an existing entry:\n",
             pp.pformat(exists.perms))

    return result


def restore(psql, bunch, iquery=None, auth_file=None, max_errors=-1):
    """Compare RBAC records with existing catalog, create missing entries.

    Returns count of failed iquery commands, 0 indicates success.

    psql - a psql_client.Psql() object
    bunch - the RBAC bunch, presumably from a backup archive
    iquery - iquery_client.IQuery() object, if None a default one is created
    auth_file - authentication file to use if no iquery client supplied
    max_errors - maximum errors to tolerate, if < 0 then tolerate all
    """
    assert psql, "No Postgres client?!"
    assert is_canonical(bunch), "Cannot restore non-canonical bunch!"
    if iquery is None:
        iquery = IQuery(afl=True, format='tsv', auth_file=auth_file)

    got = read_pg(psql=psql)
    need = merge(got, bunch)
    cmds = to_afl(need)
    if not cmds:
        dbg("Nothing to restore.")
        return 0

    def _p(s):
        """Hide display of SHA etc. when logging create_user() AFL commands."""
        m = re.search(r'(create_user\s*\([^,]*,)[^)]*\)', s)
        if m:
            return "%s ...)" % m.group(1)
        else:
            return s

    prt("Restoring access control records...")
    fails = 0
    ran = 0
    for cmd in cmds:
        prt("AFL>", _p(cmd))
        _, err = iquery(cmd)
        ran += 1
        if iquery.returncode:
            fails += 1
            warn('Query "{0}" failed:\n{1}'.format(_p(cmd), err))
            if max_errors >= 0 and fails > max_errors:
                break

    prt("Ran", ran, "of", len(cmds), "access control queries with",
        fails, "failures")
    return fails
